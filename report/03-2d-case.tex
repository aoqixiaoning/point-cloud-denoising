\chapter{2D case}

\section{Problem}
In this part, we will focus on a 2D point cloud and we will use for the energy
the area of the $ r $-offset of a point cloud $ X $: the Minkowski sum with an euclidean
ball $ B(0, r) $. This offset will be denoted by $ X^{\oplus r} $.

\section{Area of a union of balls}
In order to compute this energy, we need to know how to estimate the area of the
intersection of a ball and a Voronoi cell. Indeed, the area of the union of
balls is the same as the sum of the areas of the restrictions of the balls to
their Voronoi cell (because essentially the Voronoi cells partition the plane).

This is the same work as the one done in \cite{cazals2011computing} except that
we restrict ourselves to 2D which is simpler than in 3D.

For doing that, we need to decompose the intersection into triangles and
spherical caps.

The following figure illustrates the different cases for the intersection of a
Voronoi cell and a ball in 2D:
\begin{figure}[H]
    \centering
    \begin{minipage}{0.32\linewidth}
        \centering
        \includegraphics[scale=0.4]{2d/inter_voronoi_ball_2d}
        \subcaption{General case}
        \label{fig:inter_voronoi_ball_2d:a}
    \end{minipage}
    \begin{minipage}{0.32\linewidth}
        \centering
        \includegraphics[scale=0.4]{2d/inter_voronoi_ball_2d_no_inter}
        \subcaption{No intersections}
        \label{fig:inter_voronoi_ball_2d:b}
    \end{minipage}
    \begin{minipage}{0.32\linewidth}
        \centering
        \includegraphics[scale=0.4]{2d/inter_voronoi_ball_2d_2_inter}
        \subcaption{2 intersections}
        \label{fig:inter_voronoi_ball_2d:c}
    \end{minipage}

   \caption{Different cases for the intersection between a Voronoi cell and a sphere}
   \label{fig:inter_voronoi_ball_2d}
\end{figure}

We used \texttt{CGAL} to compute the Delaunay triangulation of our point set.
Given this triangulation, we can compute the Voronoi cell of a point by doing
the following:
\begin{enumerate}
    \item Access the neighbouring faces of a vertex using the
        \texttt{incident\_faces} method.
    \item Compute the Voronoi vertices of these faces using the \texttt{dual}
        method.
\end{enumerate}

Then, we will need to know the vertices of the boundary of the intersection (the
points forming the bold boundary in \ref{fig:inter_voronoi_ball_2d}). There are
two types of those points: some are Voronoi vertices and some are intersections
of Voronoi edges and circles. To each of these points, we attach a boolean
saying whether the point is an interior point or an intersection one. We also
attach the corresponding Voronoi edge.

Then, we loop over the Voronoi edges $ e = pq $ of a vertex $ v $:
\begin{itemize}
    \item if $ p $ and $ q $ are interior points, we add the triangle $ pvq $.
    \item if $ p $ or $ q $ is interior point, we add the triangle $ pvq $.
    \item if $ p $ and $ q $ are intersection points, then if they belong to the
        same Voronoi edge, we add the triangle $ pvq $. If not, we add the
        angular sector $ \vec{vp}, \vec{vq} $.
\end{itemize}

Some special cases need to be handled:
\begin{itemize}
    \item the boundary of the Voronoi cell is entirely outside the ball, then we
        add $ \pi r^2 $ to the area of the union (see
        \ref{fig:inter_voronoi_ball_2d:b}).
    \item the boundary consists of two intersection points $ p $ and $ q $, then
        we add the triangle $ pvq $ and the angular sector $ \vec{vp}, \vec{vq}
        $ (see \ref{fig:inter_voronoi_ball_2d:c}).
    \item there is only one point on the boundary (can happen if adjacent balls
        are tangential), then we add $ \pi r^2 $.
\end{itemize}

We used the same techniques for computing the perimeter of the boundary of the
intersection except that if there are no intersection then the perimeter is null
and instead of adding triangles areas or angular sectors, we add lengths of
circular arcs.

% TODO

\section{Automatic differentiation}

The automatic differentiation is a technique used for computing the derivatives,
gradient of expressions. It is not the same as the symbolic or the numerical
differentiation.

Indeed, automatic differentiation can be used to compute derivatives of programs
and not only mathematical functions without using approximations like with
numerical differentiation.

Let us suppose that we want to compute the derivative of a function $ f $ with a
single one dimensional argument $ x $. To do that, we will replace the number
type that is to say that we will replace $ x $ by $ x + \epsilon y $ where $
\epsilon $ with the property $ \epsilon^2 = 0 $. Then, we overload all the
arithmetical operations: addition, subtraction, multiplication, division.

Then we call $ f $ with this variable: $ f(x + \epsilon y) = x' + \epsilon y'
$. We conclude that $ x' = f(x) $ and $ y' = y f'(x) $ . Indeed for small values
of $ \epsilon $, we have the first order Taylor expansion: $ f(x + \epsilon y) =
f(x) + \epsilon y f'(x) + ... $.

This technique is interesting because it is easy to implement because by nature
we can change the number type in \texttt{CGAL} by simply changing the Kernel.

% TODO

\section{Gradient}

Then, we used the previously described automatic differentiation technique to
compute the gradient of the previously computed area.

Here are a few examples of such gradients for different input point sets:

\begin{figure}[H]
    \centering

    \begin{minipage}{0.8\linewidth}
        \centering
        \includegraphics[scale=0.32]{2d/area/ellipse-100-01-15}
        \includegraphics[scale=0.32]{2d/area/ellipse-100-01-15-gradients}
        \subcaption{100 samples on an ellipse with $ r = 15 $}
        \label{fig:gradients_area_2d_ellipse}
    \end{minipage}

    \begin{minipage}{0.8\linewidth}
        \centering
        \includegraphics[scale=0.32]{2d/area/circle-100-01-15}
        \includegraphics[scale=0.32]{2d/area/circle-100-01-15-gradients}
        \subcaption{100 samples on a circle with $ r = 15 $}
        \label{fig:gradients_area_2d_circle}
    \end{minipage}

    \begin{minipage}{0.8\linewidth}
        \centering
        \includegraphics[scale=0.32]{2d/area/square-76-001-100}
        \includegraphics[scale=0.32]{2d/area/square-76-001-100-gradients}
        \subcaption{76 samples on a square with $ r = 100 $}
        \label{fig:gradients_area_2d_square}
    \end{minipage}

    \caption{Input point set / Computed gradients}
    \label{fig:gradients_area_2d}
\end{figure}

We did the same thing using the gradient of the perimeter of the boundary on the
same point clouds.

\begin{figure}[H]
    \centering

    \begin{minipage}{0.8\linewidth}
        \centering
        \includegraphics[scale=0.32]{2d/perimeter/ellipse-100-01-15}
        \includegraphics[scale=0.32]{2d/perimeter/ellipse-100-01-15-gradients}
        \subcaption{100 samples on an ellipse with $ r = 15 $}
        \label{fig:gradients_perimeter_2d_ellipse}
    \end{minipage}

    \begin{minipage}{0.8\linewidth}
        \centering
        \includegraphics[scale=0.32]{2d/perimeter/circle-100-01-15}
        \includegraphics[scale=0.32]{2d/perimeter/circle-100-01-15-gradients}
        \subcaption{100 samples on a circle with $ r = 15 $}
        \label{fig:gradients_perimeter_2d_circle}
    \end{minipage}

    \begin{minipage}{0.8\linewidth}
        \centering
        \includegraphics[scale=0.32]{2d/perimeter/square-76-001-100}
        \includegraphics[scale=0.32]{2d/perimeter/square-76-001-100-gradients}
        \subcaption{76 samples on a square with $ r = 100 $}
        \label{fig:gradients_perimeter_2d_square}
    \end{minipage}

    \caption{Input point set / Computed gradients}
    \label{fig:gradients_perimeter_2d}
\end{figure}

In the previous screenshots, we can see that the gradients are (if the radius of
the balls are big enough and if the sampling is sufficiently uniform) in the
same direction that the normals to the underlying surface.

% TODO

\section{Relation with the mean curvature flow}

The flow we will obtain by considering the previously computed gradients will be
an approximation of the classical mean curvature flow.

Indeed, we will show that the norm of these gradients are estimations of the
mean curvature of the underlying surface.

% TODO

\section{Gradient descent}

Then, as said in the introduction, we will approximate the mean curvature flow
by applying a gradient descent algorithm where the considered energy is the area
(or the perimeter of the boundary) of the union of balls.

This gradient descent will be done using a constant timestep (Euler explicit
scheme).

We needed to choose "good" weights for the gradient descent. Indeed, in a normal
mean curvature flow, all the points move with the same distance related to the
curvature. But here, this may not be the case since the energy depends on the
curvature of our restricted region.

One way to avoid this problem is to weight the gradient by the perimeter of the
visible part of the restricted region. But by doing that, we can divide by $ 0 $
so we need to choose the time step according to these weights in order to avoid
the case where a point does not see anything.

% TODO

\section{Experiments}

We did some experiments to validate our results: we first compared the two
gradient flows (area and perimeter of the boundary) to a set of points uniformly
sampled on an ellipse.

\begin{figure}[H]
    \centering

    \includegraphics[scale=0.3]{2d/ellipse-balls-15}
    \subcaption{Minkowski sum of an ellipse and balls of radius $ 15 $}

    \includegraphics[scale=0.4]{2d/perimeter/ellipse-100-01-15}
    \includegraphics[scale=0.4]{2d/perimeter/ellipse-100-01-15-100}
    \subcaption{Perimeter flow : 0 / 100 iterations with a timestep of $ 0.5 $}
    \label{fig:ellipse_area_flow}

    \includegraphics[scale=0.4]{2d/area/ellipse-100-01-15}
    \includegraphics[scale=0.4]{2d/area/ellipse-100-01-15-100}
    \subcaption{Area flow : 0 / 100 iterations with a timestep of $ 0.1 $}
    \label{fig:ellipse_perimeter_flow}
\end{figure}

Next, we add some outliers around the ellipse and observe the effects of the two
flows.

\begin{figure}[H]
    \centering

    \includegraphics[scale=0.4]{2d/perimeter/ellipse-100-1-15-outliers}
    \includegraphics[scale=0.4]{2d/perimeter/ellipse-100-1-15-outliers-100}
    \subcaption{Perimeter flow : 0 / 100 iterations with a timestep of $ 1 $}
    \label{fig:ellipse_area_flow}

    \includegraphics[scale=0.4]{2d/area/ellipse-100-01-15-outliers}
    \includegraphics[scale=0.4]{2d/area/ellipse-100-01-15-outliers-40}
    \subcaption{Area flow : 0 / 40 iterations with a timestep of $ 0.1 $}
    \label{fig:ellipse_perimeter_flow}
\end{figure}

Then, we added some noise on these points to test the robustness of our
algorithm.

% TODO: figures
\begin{figure}[H]
    \centering

    \includegraphics[scale=0.4]{2d/ellipse-noise-5-0}
    \includegraphics[scale=0.4]{2d/perimeter/ellipse-noise-5-75}
    \subcaption{Perimeter flow : 0 / 75 iterations with a timestep of $ 0.5 $}
    \label{fig:ellipse_area_flow}

    \includegraphics[scale=0.4]{2d/ellipse-noise-5-0}
    \includegraphics[scale=0.4]{2d/area/ellipse-noise-5-75}
    \subcaption{Area flow : 0 / 75 iterations with a timestep of $ 0.05 $}
    \label{fig:ellipse_perimeter_flow}
\end{figure}

We notice that the gradient flow of the area may create holes in the point set
which is not the case for the gradient flow of the perimeter.

On the contrary, the gradient flow of the perimeter of the boundary will smooth
the point set while redistributing the points in an uniform way.

% TODO: explain why

An other experiment we did is to take points on a line segment and to fix its
endpoints. Then, we apply our flow on this point set. We expect the flow to
smooth the point set: points should get closer and closer to an uniformly
sampled set of points.

\begin{figure}[H]
    \centering

    \includegraphics[scale=0.5]{2d/perimeter/line-05-15-0}
    \includegraphics[scale=0.5]{2d/perimeter/line-05-15-50}
    \subcaption{Perimeter flow : 0 / 50 iterations with a timestep of $ 0.5 $}
    \label{fig:line_fixed_perimeter}

    \includegraphics[scale=0.5]{2d/area/line-01-15-0}
    \includegraphics[scale=0.5]{2d/area/line-01-15-50}
    \subcaption{Area flow : 0 / 50 iterations with a timestep of $ 0.1 $}
    \label{fig:line_fixed_area}
\end{figure}

% TODO: explain why

% Union of balls
% Intersection with Voronoi cells
% Volume
% Gradient descent: weights
% Experiments

% vim: set spelllang=en :
